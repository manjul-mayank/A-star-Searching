# -*- coding: utf-8 -*-
"""CS571_ AI_assignment3A.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1CCd_r6z-ukSFPgqZH4hZQUIEQ-MsvqQz
"""

import heapq
import time
import copy

# Define the goal state
goal_state = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]

def is_solvable(state):
    """Check if the given puzzle state is solvable."""
    # Flatten the state and remove the blank (0)
    flat = [num for row in state for num in row if num != 0]
    inversions = 0

    # Count inversions
    for i in range(len(flat)):
        for j in range(i + 1, len(flat)):
            if flat[i] > flat[j]:
                inversions += 1

    # For odd width puzzles, solvable if inversions are even
    return inversions % 2 == 0

# Heuristic functions (improved)
def h1(state):
    return 0  # Uniform cost search

def h2(state):
    """Misplaced tiles heuristic"""
    displaced = 0
    for i in range(3):
        for j in range(3):
            if state[i][j] != 0 and state[i][j] != goal_state[i][j]:
                displaced += 1
    return displaced

def h3(state):
    """Manhattan distance heuristic"""
    distance = 0
    for i in range(3):
        for j in range(3):
            if state[i][j] != 0:
                goal_row, goal_col = divmod(state[i][j] - 1, 3)
                distance += abs(i - goal_row) + abs(j - goal_col)
    return distance

def h4(state):
    """Custom heuristic (not admissible)"""
    return h3(state) * 1.5  # Slightly more aggressive than Manhattan

class PuzzleState:
    def __init__(self, state, g, parent=None, heuristic=h1):
        self.state = state
        self.g = g
        self.parent = parent  # Track parent for path reconstruction
        self.heuristic = heuristic(state)

    def __lt__(self, other):
        return (self.g + self.heuristic) < (other.g + other.heuristic)

    def __eq__(self, other):
        return self.state == other.state

    def __hash__(self):
        return hash(tuple(tuple(row) for row in self.state))

def astar_search(initial_state, heuristic):
    if not is_solvable(initial_state):
        return -1, None  # Unsolvable puzzle

    open_list = []
    closed_set = set()

    # Convert initial state to PuzzleState
    initial_node = PuzzleState(initial_state, 0, None, heuristic)
    heapq.heappush(open_list, initial_node)

    while open_list:
        current = heapq.heappop(open_list)

        if current.state == goal_state:
            # Reconstruct path
            path = []
            while current:
                path.append(current.state)
                current = current.parent
            return len(path) - 1, path[::-1]  # Return cost and path

        if current in closed_set:
            continue

        closed_set.add(current)

        # Find the blank (0) position
        zero_row, zero_col = next((i, j) for i, row in enumerate(current.state)
                                for j, val in enumerate(row) if val == 0)

        # Generate successors
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            new_row, new_col = zero_row + dr, zero_col + dc

            if 0 <= new_row < 3 and 0 <= new_col < 3:
                # Create new state
                new_state = [list(row) for row in current.state]
                new_state[zero_row][zero_col], new_state[new_row][new_col] = \
                    new_state[new_row][new_col], new_state[zero_row][zero_col]

                # Create new node
                new_node = PuzzleState(new_state, current.g + 1, current, heuristic)

                if new_node not in closed_set:
                    heapq.heappush(open_list, new_node)

    return -1, None  # No solution found

if __name__ == "__main__":
    # Test cases
    start_states = [
        [[1, 2, 3], [4, 5, 6], [7, 8, 0]],  # Already solved
        [[1, 2, 3], [4, 5, 6], [0, 7, 8]],    # Solvable
        [[6, 7, 3], [8, 4, 2], [1, 0, 5]],    # Solvable
        [[8, 1, 2], [0, 4, 3], [7, 6, 5]],    # Unsolvable
    ]

    heuristics = [h1, h2, h3, h4]

    for i, start_state in enumerate(start_states):
        print(f"\nTesting initial state {i + 1}:")
        for row in start_state:
            print(row)

        if not is_solvable(start_state):
            print("This puzzle is not solvable!")
            continue

        for j, heuristic in enumerate(heuristics):
            print(f"\nUsing heuristic h{j + 1}:")
            start_time = time.time()
            cost, path = astar_search(start_state, heuristic)
            end_time = time.time()

            if cost >= 0:
                print(f"Solution found in {cost} moves")
                print(f"Time taken: {end_time - start_time:.4f} seconds")
                print("Final path length:", len(path))
            else:
                print("No solution found (but puzzle should be solvable)")